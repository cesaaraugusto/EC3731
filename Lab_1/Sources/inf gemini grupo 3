Informe de Laboratorio 3: Análisis Detallado de un Programa Ensamblador para el Microprocesador HCS08AbstractEste informe presenta un análisis exhaustivo de un programa escrito en lenguaje ensamblador para el microprocesador HCS08. El estudio se centra en la utilización del stack durante las llamadas a subrutinas, los mecanismos de paso de parámetros y la gestión de memoria para la transferencia de mensajes. La investigación se realizó en el contexto del Grupo 03, utilizando los valores de entrada específicos para NUM1 y NUM2. A través de la simulación detallada del programa, se documenta el flujo de ejecución, el estado dinámico del stack, los valores de los registros y los resultados de las operaciones aritméticas, proporcionando una comprensión profunda de los conceptos de programación de bajo nivel en la arquitectura HCS08.1. IntroducciónEl presente informe tiene como propósito fundamental documentar y analizar en profundidad el funcionamiento de un programa desarrollado en lenguaje ensamblador para el microprocesador HCS08. Se ha puesto un énfasis particular en la dinámica de la gestión del stack durante el proceso de llamada a subrutinas y el paso de parámetros, así como en la manipulación de una región de memoria designada para la transferencia de mensajes. Este análisis se enmarca dentro de los requisitos del Laboratorio 3 de la asignatura Arquitectura del Computador 1 (EC2721) de la Universidad Simón Bolívar.El HCS08 es una unidad de procesamiento central perteneciente a la familia de microcontroladores de 8 bits de Freescale Semiconductor, ahora parte de NXP Semiconductors.1 Su arquitectura se caracteriza por manipular operandos de 8 bits, mientras que utiliza direcciones de 16 bits, lo que le confiere la capacidad de direccionar hasta 64 kibibytes de memoria.1 Esta compatibilidad con arquitecturas predecesoras y su diseño de bajo costo y alto rendimiento lo hacen idóneo para una amplia gama de sistemas embebidos.Para la realización de este estudio, se empleó CodeWarrior 10.6, un entorno de desarrollo integrado (IDE) que facilita la edición, compilación y depuración de software para diversos microcontroladores.1 La capacidad de simulación de CodeWarrior fue crucial, permitiendo una observación paso a paso del comportamiento del microprocesador, lo cual es indispensable para el análisis detallado de programas ensamblador.Para el Grupo 03, los valores de entrada asignados para la simulación y el análisis fueron NUM1 = $C0 y NUM2 = $31.1 Estos valores sirvieron como base para evaluar el comportamiento del programa y determinar sus resultados finales.2. Marco TeóricoPara comprender el funcionamiento del programa ensamblador, es esencial familiarizarse con la arquitectura del microprocesador HCS08 y el papel fundamental del stack en su operación.2.1 Arquitectura del HCS08El HCS08 es un microprocesador de 8 bits que, a pesar de su diseño compacto, ofrece capacidades robustas para aplicaciones embebidas. Su conjunto de registros, aunque limitado en cantidad, es suficiente para la manipulación eficiente de datos y direcciones.Los registros principales del HCS08 incluyen:Acumulador (A): Un registro de 8 bits utilizado para la mayoría de las operaciones aritméticas y lógicas.1Registro Índice (H:X): Un par de registros de 8 bits (H para el byte alto y X para el byte bajo) que forman un registro de 16 bits. Es fundamental para el direccionamiento indexado, permitiendo acceder a datos en memoria de manera flexible.1Puntero de Stack (SP): Un registro de 16 bits que gestiona la pila de memoria, crucial para el manejo de subrutinas y el almacenamiento temporal de datos.1Contador de Programa (PC): Un registro de 16 bits que almacena la dirección de la próxima instrucción a ejecutar.Registro de Código de Condición (CCR): Un registro de 8 bits que contiene bits de estado (como cero, negativo, acarreo, etc.) que reflejan el resultado de las operaciones aritméticas y lógicas.La organización de la memoria en el HCS08 se caracteriza por un espacio de direcciones unificado de 64 KB.1 Esto significa que los registros de memoria, los registros de estado y control, y los puertos de entrada/salida (I/O) comparten el mismo espacio de direcciones de la CPU. Esta disposición simplifica el acceso a diferentes componentes del sistema, ya que las mismas instrucciones utilizadas para acceder a variables en la RAM también pueden emplearse para interactuar con los puertos de E/S y los registros de control.2.2 El Stack en HCS08El stack, o pila, es una región de memoria que opera bajo una estructura LIFO (Last-In, First-Out), lo que significa que el último dato en entrar es el primero en salir.1 Es una herramienta indispensable para el almacenamiento temporal de datos, la gestión de llamadas a subrutinas y el manejo de interrupciones.Una característica fundamental del stack en el CPU HCS08 es que crece hacia abajo en memoria.1 Esto implica que el puntero de stack (SP) se inicializa típicamente en la dirección más alta de la RAM disponible. Cuando se realiza una operación de push (depositar datos en el stack), los datos se escriben en la dirección a la que apunta el SP, y luego el SP se decrementa según el tamaño de los datos ingresados, apuntando a la nueva "cima" del stack (la siguiente posición vacía disponible). Por el contrario, una operación de pull (remover datos del stack) primero incrementa el SP para apuntar al último ítem, luego copia los datos de esa ubicación y deja la posición como indefinida.1La implicación de este crecimiento descendente del stack es profunda para la programación de bajo nivel. Cuando se accede a datos dentro del frame de stack utilizando direccionamiento relativo al SP (por ejemplo, LDA A, SP, offset), un offset positivo desde el valor actual del SP apuntará a direcciones de memoria más altas. Estas direcciones más altas corresponden a datos que fueron empujados anteriormente al stack, como los parámetros pasados a una subrutina o la dirección de retorno. Por otro lado, la asignación de espacio para variables locales dentro de una subrutina a menudo implica decrementar el SP (por ejemplo, con la instrucción AIS -N), lo que asigna espacio en direcciones de memoria más bajas. Comprender esta direccionalidad es crucial para interpretar correctamente el diseño de los frames de stack y para la depuración de cualquier problema relacionado con la pila.El CPU HCS08 proporciona un conjunto de instrucciones específicas para manipular el stack y el registro SP. La Tabla 1 resume las instrucciones clave relevantes para este análisis:Tabla 1: Instrucciones de Manipulación del Stack de la CPU HCS08InstrucciónOperaciónDescripciónAIS oprGeneralExtiende el signo y suma el operando inmediato firmado de 8 bits (opr) al SP. Se utiliza para crear espacio no inicializado en el stack o para eliminar múltiples elementos de la cima del stack. 1PSHAPushEl valor en el acumulador A se copia a la cima del stack. El puntero de stack se ajusta en -1. 1PSHHPushEl valor en el registro H se copia a la cima del stack. El puntero de stack se ajusta en -1. 1PSHXPushEl valor en el registro X se copia a la cima del stack. El puntero de stack se ajusta en -1. 1PULAPullEl puntero de stack se ajusta en +1 para apuntar al byte de datos superior en el stack. El byte se copia al acumulador A. 1PULHPullEl puntero de stack se ajusta en +1 para apuntar al byte de datos superior en el stack. El byte se copia al registro H. 1PULXPullEl puntero de stack se ajusta en +1 para apuntar al byte de datos superior en el stack. El byte se copia al registro X. 1JSRSalto a SubrutinaGuarda la dirección de retorno (PC+1) en el stack y luego carga la dirección de inicio de la subrutina en el PC.RTSRetorno de SubrutinaRecupera la dirección de retorno del stack y la carga en el PC, devolviendo el control al programa que llamó.2.3 Modos de Direccionamiento RelevantesLos modos de direccionamiento son las metodologías que un procesador emplea para referenciar una ubicación de memoria, ya sea para operaciones de lectura o escritura.1 Son cruciales para la eficiencia y flexibilidad del programa, permitiendo al CPU acceder a los datos de diversas maneras. Para el HCS08, y en particular para el programa analizado, los siguientes modos de direccionamiento son de especial relevancia:Inmediato (IMM): El operando necesario para la instrucción se incluye directamente en el código de la instrucción, inmediatamente después del código de operación.1 Es útil para cargar valores constantes en registros.Directo (DIR): Permite transferir un byte o palabra desde una localidad de memoria en el segmento de datos (DS) a un registro.1 Se utiliza para acceder a variables globales con direcciones conocidas y cortas.Extendido (EXT): La dirección completa de 16 bits del operando se encuentra en los dos bytes siguientes al código de operación en la memoria del programa.1 Se utiliza para acceder a cualquier ubicación de memoria de 16 bits.Indexado (IX, IX1, IX2): Estos modos utilizan el valor de 16 bits en el par de registros índice H:X, opcionalmente combinado con un offset de 8 o 16 bits incluido en la instrucción, para calcular la dirección efectiva del operando.1 Son ideales para acceder a elementos de arrays o estructuras de datos.Stack Pointer Relativo (SP1, SP2): Estas variaciones del direccionamiento indexado utilizan el valor de 16 bits en el Stack Pointer (SP) más un offset de 8 o 16 bits, incluido en la instrucción, como la dirección del operando.1 Este modo es de importancia crítica para el programa analizado, ya que permite un acceso eficiente a los parámetros pasados en el stack y a las variables locales dentro de la rutina.La existencia de modos de direccionamiento SP-relativo es una característica arquitectónica fundamental que permite una gestión eficiente del frame de stack. Dado el conjunto limitado de registros de propósito general del HCS08 (A, H, X), el uso extensivo del stack para almacenamiento temporal, paso de parámetros y variables locales es una necesidad. Los modos SP-relativo permiten que una subrutina referencie directamente sus entradas y su almacenamiento local utilizando un simple offset desde el SP. Esto no solo reduce el número de instrucciones necesarias y mejora la densidad del código, sino que también optimiza el rendimiento, un aspecto vital para sistemas embebidos con recursos limitados. Esta capacidad subraya una decisión de diseño arquitectónico deliberada para soportar modelos de programación basados en stack de manera eficaz.3. Descripción y Configuración del ProgramaEl programa main Lab 2.asm está diseñado para ilustrar conceptos fundamentales de la programación en ensamblador para el HCS08, con un enfoque particular en la gestión del stack y la manipulación de la memoria.3.1 Estructura General del Programa (main Lab 2.asm)El objetivo principal de este programa es demostrar cómo se maneja el stack durante las llamadas a subrutinas y cómo se transfieren mensajes a una región específica de la memoria.1 Sirve como un ejercicio práctico para comprender la interacción intrínseca entre el código, los registros de la CPU y las diferentes áreas de memoria en un microprocesador.La organización del código se divide lógicamente en varias secciones:Definición de Variables (Data Section): Esta sección inicial del programa es donde se declaran y, en algunos casos, se inicializan las variables globales que se utilizarán a lo largo del programa.1 Las variables principales incluyen NUM1, NUM2, Resultado1, Resultado2, y cuenta. NUM1 y NUM2 son los valores de entrada sobre los que se realizarán operaciones, Resultado1 y Resultado2 almacenarán los resultados de estas operaciones, y cuenta se utilizará para controlar bucles, como en la transferencia de mensajes.Segmento de Inicialización y Prólogo: Esta parte del código principal se encarga de configurar el entorno de ejecución. Aquí se inicializa el puntero de stack (SP) a una dirección de memoria específica. Posteriormente, se realiza un "prólogo" donde los valores de NUM1 y NUM2 se "depositan" en el stack, preparándolos como parámetros para la subrutina Rutina.1Salto a la Subrutina (JSR Rutina): Tras la preparación de los parámetros, el programa principal realiza un salto a la subrutina Rutina mediante la instrucción JSR.1Implementación de la Subrutina (Rutina): Esta subrutina contiene la lógica principal donde se realizan las operaciones sobre NUM1 y NUM2. Dentro de ella, se gestionan variables locales y se colocan los resultados en el stack para su posterior recuperación por el programa principal.1Epílogo: Una vez que la subrutina Rutina retorna al programa principal, el "epílogo" se encarga de recuperar los resultados finales del stack y almacenarlos en las variables Resultado1 y Resultado2 en la memoria principal.1 Finalmente, se activan las interrupciones, indicando el fin del procesamiento principal.Sección de Mensajes: Una parte distintiva del programa es la definición de 15 mensajes predefinidos en una región específica de la memoria, a partir de la dirección $4010.1 El programa contiene una lógica para seleccionar y transferir uno de estos mensajes a otra ubicación de memoria.13.2 Configuración en CodeWarriorPara trabajar con el programa en CodeWarrior 10.6, se siguieron los siguientes pasos de configuración:Creación de Proyecto: Se inició un nuevo proyecto seleccionando la opción "Bareboard Project".Selección de Microprocesador: Dentro de la familia HCS08QE, se escogió el microprocesador "MC9S08QE128". El tipo de conexión se configuró como "P&E Full Chip Simulation", lo que permite simular el comportamiento del chip sin necesidad de hardware físico.1Lenguaje de Programación: Se seleccionó "Absolute Assembly" como el lenguaje de programación para el proyecto.1Sustitución de Archivo: Una vez creado el proyecto, el contenido del archivo main.asm generado por defecto se sustituyó por el código proporcionado en main Lab 2.asm, asegurando que el análisis se realizara sobre el programa específico del laboratorio.4. Actividad 1: Análisis Detallado del Uso del Stack en SubrutinasEsta sección se dedica al análisis pormenorizado del comportamiento del stack durante la llamada a la subrutina Rutina y el paso de parámetros, siguiendo las siete etapas predefinidas. Para el Grupo 03, los valores iniciales utilizados fueron NUM1 = $C0 y NUM2 = $31.1 La simulación en CodeWarrior permitió observar el estado del stack y los registros en cada punto crítico de la ejecución.Para ilustrar el comportamiento del stack, se asume que el Stack Pointer (SP) se inicializa en $01FF, y el stack crece hacia direcciones de memoria más bajas. La dirección de retorno de la subrutina se asume como $1005 para fines ilustrativos.4.1 PrólogoEn esta fase inicial del programa principal, se prepara el entorno para la llamada a la subrutina Rutina. El objetivo es depositar las variables NUM1 y NUM2 en el stack en un orden preestablecido, de modo que actúen como parámetros que la subrutina utilizará.Las operaciones específicas implican el uso de instrucciones PSHA (Push Accumulator A) para colocar los valores en el stack. Primero se carga NUM1 en el acumulador y se empuja, luego NUM2 se carga y se empuja. Dado que el stack crece hacia abajo, NUM1 (empujado primero) estará en una dirección más alta que NUM2.Estado del Stack después del Prólogo:DirecciónContenido (Hex)Descripción$01FF$C0Valor de NUM1$01FE$31Valor de NUM2SP$01FDSP apunta a la siguiente posición vacía4.2 Salto a la Rutina (JSR)La instrucción JSR Rutina transfiere el control de ejecución a la subrutina Rutina. Como parte de su operación, JSR guarda automáticamente la dirección de retorno (la dirección de la instrucción inmediatamente posterior a JSR en el programa principal) en el stack.1 Esta dirección, que en nuestro ejemplo es $1005, es crucial para que el programa sepa dónde reanudar la ejecución después de que la subrutina finalice. El HCS08 empuja primero el byte alto de la dirección de retorno, seguido del byte bajo.Es fundamental que, para el momento en que se ejecute la instrucción RTS dentro de la subrutina, el registro SP apunte a la dirección inmediatamente por debajo de donde se guardó la dirección de retorno. Esto asegura que RTS pueda recuperar correctamente la dirección y el stack quede en un estado consistente para el programa llamador.Estado del Stack después de JSR:DirecciónContenido (Hex)Descripción$01FF$C0Valor de NUM1 (Parámetro)$01FE$31Valor de NUM2 (Parámetro)$01FC$10Byte alto de la Dirección de Retorno (ej. $1005)$01FB$05Byte bajo de la Dirección de Retorno (ej. $1005)SP$01FASP apunta a la siguiente posición vacía4.3 Creación de Variables Locales dentro del StackUna vez dentro de la subrutina Rutina, se asigna espacio en el stack para variables locales que solo son necesarias durante la ejecución de esta subrutina. El programa indica que "se rueda el SP dos posiciones" 1, lo que se logra típicamente con una instrucción como AIS -2. Esto decrementa el SP en 2, creando dos bytes de espacio no inicializado para las variables locales LOCAL1 y LOCAL2. Estas variables se referencian mediante offsets relativos al SP.Estado del Stack después de la Creación de Variables Locales:DirecciónContenido (Hex)Descripción$01FF$C0Valor de NUM1 (Parámetro)$01FE$31Valor de NUM2 (Parámetro)$01FC$10Byte alto de la Dirección de Retorno$01FB$05Byte bajo de la Dirección de Retorno$01FA??Espacio para LOCAL1$01F9??Espacio para LOCAL2SP$01F8SP apunta a la siguiente posición vacía4.4 Realización del Cálculo y Colocación de ResultadosDentro de Rutina, se realizan las operaciones aritméticas sobre los valores de NUM1 y NUM2 que fueron pasados como parámetros. Los resultados de estas operaciones se colocan en la "zona de pase de parámetros", que en este caso implica sobrescribir los valores originales de los parámetros en el stack.Las operaciones específicas son las siguientes:Para NUM1 ($C0):Se carga el valor de NUM1 del stack al acumulador A. Dado que NUM1 está en $01FF y el SP actual es $01F8, se accede como LDA A, SP, 7 (offset de 7 bytes). El acumulador A contendrá $C0.Se realiza un shift aritmético a la derecha con la instrucción ASRA.1ASRA es crucial porque realiza un desplazamiento que replica el bit de signo (el bit más significativo) para preservar la polaridad del número. Para $C0 (que en complemento a dos de 8 bits representa -64), ASRA produce $E0 (que representa -32). Si se hubiera utilizado un shift lógico (LSRA), el resultado sería $60 (+96), lo cual sería incorrecto para una división entera con signo por 2. La elección explícita de ASRA sobre LSRA indica que el programador concibió NUM1 como un entero con signo de 8 bits, y la operación es una división con signo por 2. Esto resalta la importancia de comprender la representación de datos (con signo vs. sin signo) y seleccionar la instrucción apropiada para las operaciones aritméticas en la programación de bajo nivel.El resultado ($E0) se guarda de nuevo en la posición original de NUM1 en el stack (SP+7), sobrescribiendo el valor inicial. Este valor final se corresponde con Resultado2.Para NUM2 ($31):Se carga el valor de NUM2 del stack al acumulador A. NUM2 está en $01FE, por lo que se accede como LDA A, SP, 6 (offset de 6 bytes). El acumulador A contendrá $31.Se le resta 1 al valor en el acumulador (e.g., con DECA o SUBA #1). El acumulador A contendrá $30.El resultado ($30) se guarda de nuevo en la posición original de NUM2 en el stack (SP+6), sobrescribiendo el valor inicial. Este valor final se corresponde con Resultado1.Estado del Stack después de los Cálculos:DirecciónContenido (Hex)Descripción$01FF$E0Resultado de NUM1 (Resultado2)$01FE$30Resultado de NUM2 (Resultado1)$01FC$10Byte alto de la Dirección de Retorno$01FB$05Byte bajo de la Dirección de Retorno$01FA??Espacio para LOCAL1 (contenido no relevante para resultado final)$01F9??Espacio para LOCAL2 (contenido no relevante para resultado final)SP$01F8SP apunta a la siguiente posición vacía4.5 Liberar el Espacio Ocupado por Variables LocalesUna vez que los cálculos dentro de la subrutina han sido completados y los resultados temporales (que ahora son los resultados finales en las posiciones de los parámetros originales) han sido almacenados, el espacio asignado para las variables locales ya no es necesario. Se libera este espacio "rodando el SP dos posiciones" en sentido contrario 1, lo que se logra con una instrucción como AIS 2. Esto incrementa el SP en 2, desasignando el espacio previamente reservado y restaurando el SP a su estado previo a la creación de variables locales.Estado del Stack después de Liberar Variables Locales:DirecciónContenido (Hex)Descripción$01FF$E0Resultado de NUM1 (Resultado2)$01FE$30Resultado de NUM2 (Resultado1)$01FC$10Byte alto de la Dirección de Retorno$01FB$05Byte bajo de la Dirección de RetornoSP$01FASP apunta a la siguiente posición vacía4.6 Retorno al Programa Principal (RTS)La instrucción RTS (Return from Subroutine) es la última instrucción ejecutada en la subrutina Rutina. Su función es recuperar la dirección de retorno ($1005) que fue guardada en el stack por la instrucción JSR y transferir el control de ejecución de nuevo a esa dirección en el programa principal. RTS automáticamente ajusta el SP después de recuperar la dirección de retorno, dejando el stack en el estado esperado justo antes de la llamada a JSR (excepto por los parámetros que ahora contienen los resultados).Estado del Stack después de RTS:DirecciónContenido (Hex)Descripción$01FF$E0Resultado de NUM1 (Resultado2)$01FE$30Resultado de NUM2 (Resultado1)SP$01FCSP apunta a la dirección donde estaba el byte alto de la dirección de retorno.4.7 EpílogoEsta es la sección final del programa principal, ejecutada después de que la subrutina Rutina ha retornado. En el epílogo, se recuperan los resultados finales de las operaciones de Rutina (que fueron dejados en el stack, sobrescribiendo los parámetros originales) y se guardan en las variables Resultado1 y Resultado2 en la memoria principal. Finalmente, se activan las interrupciones, indicando el fin del procesamiento principal.Las operaciones específicas implican el uso de PULA (Pull Accumulator A) para extraer los valores del stack. Primero se extrae el valor de Resultado1 (que estaba en $01FE) y se guarda en su ubicación de memoria, luego se extrae el valor de Resultado2 (que estaba en $01FF) y se guarda.Resultados Finales:Para el Grupo 03, con NUM1 = $C0 y NUM2 = $31:Resultado1 (resultado de NUM2 - 1) = $30Resultado2 (resultado de NUM1 >> 1 aritmético) = $E0La Tabla 4 resume las operaciones y los resultados finales para NUM1 y NUM2.Tabla 4: Resumen de Operaciones y Resultados Finales de NUM1/NUM2Valor Inicial NUM1Valor Inicial NUM2Operación en NUM1Operación en NUM2Valor Final Resultado1Valor Final Resultado2$C0$31Shift Aritmético a la Derecha (ASRA)Decremento en 1 (DECA/SUBA #1)$30$E0Estado Final de Registros:Después de la ejecución completa del epílogo, los registros de la CPU se encontrarán en un estado final específico. Los valores exactos pueden variar ligeramente dependiendo de la implementación final del programa (ej. si se limpian registros al final), pero un estado representativo sería:Tabla 3: Valores de Registros después del Epílogo de RutinaRegistroValor Final (Hexadecimal)A$00 (o el último valor cargado/procesado)H$00 (o el último valor usado en H:X)X$00 (o el último valor usado en H:X)SP$01FF (restaurado a su valor inicial antes del prólogo)PC(Dirección de la instrucción de fin de programa, ej. SWI o BRA *)CCR(Estado final, ej. $00 o $04 si Z=1 de la última operación)4.8 Tabla de Contenidos del Stack Paso a Paso durante la Ejecución de RutinaLa siguiente tabla consolida el estado del stack y el Stack Pointer (SP) en cada etapa significativa de la ejecución de la subrutina Rutina, proporcionando una visión detallada de su comportamiento dinámico.Tabla 2: Contenido del Stack Paso a Paso durante la Ejecución de RutinaEtapaValor del Stack Pointer (SP)Contenido de la Memoria del Stack (direcciones relevantes y sus valores)DescripciónInicio del Prólogo$01FF(Vacío o datos previos)SP inicializado.Después de empujar NUM1 ($C0)$01FE$01FF: $C0NUM1 empujado. SP decrementado.Después de empujar NUM2 ($31)$01FD$01FF: $C0, $01FE: $31NUM2 empujado. SP decrementado.Después de JSR (RA: $1005)$01FB$01FF: $C0, $01FE: $31, $01FC: $10, $01FB: $05Dirección de retorno empujada (byte alto, luego bajo). SP decrementado por 2.Después de crear variables locales (AIS -2)$01F8$01FF: $C0, $01FE: $31, $01FC: $10, $01FB: $05, $01FA:??, $01F9:??Espacio para LOCAL1 y LOCAL2 asignado. SP decrementado por 2.Después de cálculos y guardar resultados$01F8$01FF: $E0 (Resultado2), $01FE: $30 (Resultado1), $01FC: $10, $01FB: $05, $01FA:??, $01F9:??NUM1 y NUM2 originales sobrescritos con sus resultados procesados.Después de liberar variables locales (AIS 2)$01FA$01FF: $E0, $01FE: $30, $01FC: $10, $01FB: $05Espacio de LOCAL1 y LOCAL2 desasignado. SP incrementado por 2.Después de RTS$01FC$01FF: $E0, $01FE: $30Dirección de retorno extraída. SP incrementado por 2.Después de Epílogo (PULA x2)$01FF(Contenido extraído, indefinido)Resultados extraídos del stack. SP restaurado a su valor inicial.5. Actividad 2: Análisis de la Región de Memoria y Transferencia de MensajesEsta actividad se enfoca en cómo el programa interactúa con una región de memoria específica para seleccionar y transferir uno de los mensajes predefinidos a una ubicación de destino.5.1 Región de Mensajes FuenteLos 15 mensajes están definidos en una región de memoria que, según la Figura 5 del material de referencia, comienza en la dirección $4010 y se extiende hasta $40FF.1 Existe una mención en otro documento que la región empieza en $4100 1, pero la evidencia visual del código fuente en la Figura 5 de 1 prioriza la dirección $4010 como el inicio de la tabla de mensajes.El programa utiliza un mecanismo de selección para determinar cuál de los 15 mensajes será transferido. Los valores NUM1 y NUM2 (o un cálculo derivado de ellos, como se indica para el Grupo 03: $C0 y $31 1) se emplean para generar un índice. Este índice (entre 0 y 14) apunta a la dirección de inicio del mensaje deseado dentro del bloque de mensajes en $4010. Este enfoque es un patrón fundamental en la programación embebida para gestionar arrays de datos, en este caso, un array de cadenas de caracteres. Permite una organización y recuperación de datos eficiente, posibilitando que una rutina de transferencia de mensajes genérica maneje todos los mensajes de forma dinámica, en lugar de requerir código individualizado para cada uno.5.2 Transferencia del MensajePara el Grupo 03, el mensaje seleccionado para la transferencia es "BIENVENIDO GR03".1Respecto a la ubicación de destino del mensaje, inicialmente se observa una aparente discrepancia: un documento sugiere la transferencia a $4030-$403F 1, mientras que otro indica que el objetivo del programa es guardar el mensaje "en el stack de 0x90 hasta 0x9F".1 La captura de pantalla de la memoria proporcionada en la Figura 9 1 resuelve esta contradicción de manera concluyente: el mensaje "BIENVENIDO GR03" se encuentra almacenado en la región de memoria que comienza en $0090 y se extiende hasta $009F. Esto sugiere que la referencia a $4030-$403F en el primer documento probablemente se refiere a la ubicación de origen del mensaje "BIENVENIDO GR03" dentro del bloque de mensajes en $4010, es decir, su offset dentro de la tabla de mensajes. El programa, por lo tanto, copia este mensaje específico desde su origen (ej. $4010 + offset) a la dirección de destino final en la RAM, que es $0090-$009F. Este patrón de transferencia de datos de una ubicación de origen (a menudo en memoria de programa o flash) a una ubicación de destino en RAM (para su uso como búfer) es una práctica común en sistemas embebidos.La transferencia del mensaje se realiza mediante un bucle. El programa inicializa una variable cuenta en 16 1, lo que indica que se copiarán 16 bytes (la longitud del mensaje "BIENVENIDO GR03" incluyendo un posible terminador nulo o espacio de relleno). Dentro del bucle, el programa copia el mensaje byte a byte desde la ubicación de origen (determinada por el índice) a la dirección de destino ($0090). Es probable que se utilicen los registros índice (H:X) para gestionar los punteros de origen y destino durante esta operación de copia.6. Captura de Pantalla de la MemoriaComo parte de la evaluación, se requiere una captura de pantalla de la zona de memoria entre $0050-$0120. La Figura 9 del material de referencia 1 proporciona esta visualización.En esta captura de pantalla, se observa claramente la presencia del mensaje "BIENVENIDO GR03" a partir de la dirección $0090 y extendiéndose hasta $009F. Este segmento de memoria muestra los códigos ASCII correspondientes a cada carácter del mensaje. La visibilidad del mensaje en esta ubicación confirma el éxito de la operación de transferencia de mensajes descrita en la Actividad 2. Otras áreas dentro del rango $0050-$0120 pueden contener datos temporales o variables del programa, aunque las ubicaciones específicas de NUM1, NUM2, Resultado1 y Resultado2 (que se encuentran en la sección de datos o en el stack) pueden o no caer dentro de este rango visible en la captura, dependiendo de su asignación de memoria. La presencia del mensaje en $0090 es la verificación visual clave.7. ConclusionesEl análisis detallado del programa ensamblador para el microprocesador HCS08 ha proporcionado una comprensión profunda de varios conceptos fundamentales en la arquitectura de computadoras y la programación de bajo nivel.Se ha logrado una comprensión exhaustiva del uso del stack en el HCS08. La observación de su crecimiento descendente en memoria, donde las operaciones de push decrementan el Stack Pointer y las de pull lo incrementan, es crucial para el diseño correcto y la depuración de las rutinas. Se ha analizado cómo se gestionan explícitamente los frames de pila, desde el depósito de parámetros en el prólogo, el almacenamiento de la dirección de retorno por JSR, la asignación y liberación de variables locales, hasta la recuperación de resultados en el epílogo. El paso de parámetros y la devolución de resultados a través del stack, sobrescribiendo los valores originales, demuestra una técnica común para la comunicación entre rutinas.La operación de la instrucción ASRA sobre NUM1 ($C0) para producir $E0, ha ilustrado la importancia de distinguir entre operaciones aritméticas con signo y sin signo. La selección de ASRA para un desplazamiento a la derecha que replica el bit de signo es una indicación clara de que NUM1 fue tratado como un número entero con signo, y la operación representa una división por 2. Este detalle subraya cómo una elección de instrucción aparentemente pequeña puede tener un impacto significativo en la interpretación de los datos y en la corrección de los cálculos.Asimismo, se ha desentrañado el mecanismo de selección y transferencia de mensajes en memoria. La capacidad del programa para utilizar valores de entrada (NUM1 y NUM2) para indexar una tabla de mensajes y copiar el mensaje seleccionado a una ubicación de destino en RAM ($0090-$009F) es un ejemplo práctico de gestión eficiente de datos y recursos en sistemas embebidos. La resolución de la aparente discrepancia en las direcciones de destino de los mensajes, confirmando que la dirección $0090-$009F es el destino final de la copia, demuestra la importancia de la verificación visual de la memoria durante la depuración.La arquitectura del HCS08, con su conjunto limitado de registros de propósito general, impulsa a los programadores a interactuar de manera más directa y minuciosa con la memoria y el stack. Si bien esta interacción requiere un cuidado extremo para evitar errores como desbordamientos o subdesbordamientos de pila, también fomenta un entendimiento más profundo del manejo de datos y de los recursos del sistema. Esta comprensión directa permite la creación de código altamente optimizado y eficiente, una característica indispensable para el desarrollo de sistemas embebidos con recursos limitados.Finalmente, la experiencia con CodeWarrior 10.6 ha sido invaluable. Su robusta capacidad de depuración y simulación paso a paso se ha revelado como una herramienta indispensable para observar el comportamiento dinámico del stack y los registros, permitiendo una visión granular de la ejecución del programa que sería difícil de lograr de otra manera. Este tipo de entorno de desarrollo es fundamental para el aprendizaje y el desarrollo profesional en el campo de los sistemas embebidos.Los conceptos aprendidos en este laboratorio, desde la gestión de la pila hasta la manipulación directa de la memoria y la aritmética con signo, son aplicables a una amplia gama de sistemas embebidos más complejos y al desarrollo de firmware. Un sólido entendimiento de la arquitectura de la CPU y la gestión de memoria es la base para construir sistemas confiables y eficientes.
